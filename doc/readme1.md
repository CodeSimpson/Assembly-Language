# 汇编语言

### 第一章 基础知识

首先需要明确的是，汇编语言直接操作硬件，与硬件平台息息相关，本文档与相关程序基于8086CPU，参考书籍为《汇编语言---王爽》。

#### 1.1 汇编语言的组成

由于直接操作机器码复杂且难以识别及维护，为了方便程序员编写程序，汇编语言诞生了，程序员通过汇编指令编写程序，相关指令与人类语言相近，再通过编译器，将汇编程序翻译为机器码，方便了程序的书写和阅读。

汇编语言主要由**3类**指令组成：

* 汇编指令：机器码的助记符，有与之对应的机器码
* 伪指令：没有对应的机器码，由编译器识别并执行，机器实际并不执行
* 其他符号：如+、-、*、/ 等，由编译器识别，也没有对应的机器码

#### 1.2 存储单元

指令和数据保存于内存或磁盘中，本质都是二进制数据。电子计算机的最小信息单位是bit，也就是一个0/1位，微型计算机存储器的存储单元为一个Byte，即8个二进制位。8086PC的内存地址空间大小为1MB，即 $2^{20}$ 个存储单元。

CPU对存储器的读写必需进行3种信息的传递：

* 地址信息传递：确定将要操作的内存单元地址
* 控制信息传递：确定读或写等控制操作
* 数据信息传递

分别对应3种总线：

* 地址总线：宽度决定CPU可以寻址的最大内存地址范围
* 控制总线：宽度决定CPU对外部器件的控制能力
* 数据总线：宽度决定数据的传输效率

#### 1.3 计算机的基本硬件设备

* 主板：计算机主要器件的载体，这些器件通过总线连接，包含：CPU、存储器、外围芯片组、扩展插槽等。

* 接口卡：CPU对外部器件不能直接控制，如显示器、音箱、打印机等，直接控制这些外部设备进行工作的是插在扩展插槽的接口卡，CPU通过直接控制这些接口卡，间接控制外设。

* 存储器：PC中安装有多个存储器芯片，这些芯片在物理连接上是独立的不同器件，根据功能和连接可以分为

  * 随机存储器：装在主板上的RAM和插在扩展插槽上的RAM，就是内存
  * 装有BIOS的只读存储器：ROM
  * 接口卡上的RAW：显存等

  虽然PC中多种存储器芯片物理上相互独立，但从CPU的角度来看，所有的物理存储器都被看做一个由若干存储单元组成的逻辑存储器，可以连续访问。



### 第二/三章 寄存器

CPU由运算器、控制器、寄存器等器件构成，通过CPU内部总线连接。8086CPU中有14个寄存器，每个寄存器都有一个名称：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。每个寄存器都为16位。

#### 2.1 寄存器分类

| 分类             | 寄存器         | 备注                                                         |
| ---------------- | -------------- | ------------------------------------------------------------ |
| 通用寄存器reg    | AX、BX、CX、DX | 这4个寄存器都可以分位两个独立使用的8位寄存器：\*H和\*L。可以通过`mov ax 123`直接修改寄存器的值 |
| 段寄存器sreg     | CS、DS、SS、ES | 8086CPU访问内存单元时由这四个寄存器提供内存单元的段地址，不能被MOV指令直接赋值【`mov ds, 10h`】 |
| 代码段寄存器     | CS             | 不能被MOV指令直接赋值，同时修改CS: IP内容的方法，`jmp 段地址：偏移地址` |
| 指令指针寄存器   | IP             | 不能被MOV指令直接赋值，单独修改IP的方法，`jmp ax`            |
| 内存段地址寄存器 | DS             | 用来存储要访问数据的段地址，**8086CPU不支持将数据直接送入段寄存器的操作**，`mov ds ax`或`mov ds [0]`可行 |
| 栈段寄存器       | SS             | 保存代表栈的内存单元的段地址                                 |
| 栈顶指针寄存器   | SP             | 保存栈顶的内存单元地址                                       |

#### 2.2 8086CPU给出物理地址的方法

8086CPU有20位地址总线，可以传送20位地址，寻址范围为1MB【$2^{20}Byte$】，但CPU内存又是16位结构，其一次性处理、存储、传输的地址为16位，那么CPU是怎么输出20位地址码的呢？

**8086CPU采用在内部用两个16位地址合成的方法来形成一个20位的物理地址，16位段地址 * 16 + 16位偏移地址 = 20位物理地址**。

从上面公式可以看出：

* 段地址x16必然是16的倍数，所以一个段的起始地址也一定是16的倍数。
* 偏移地址为16位，最大寻址能力为64KB，所以一个段的长度最大为64KB。

#### 2.3 栈

* 8086CPU的入栈和出栈操作都是以**字* **为单位进行的。

* 任意时刻，SS:SP指向栈顶元素。
* 在内存空间中，元素**入栈**，SP指向的内存**地址减小**；当栈为空时，SS:SP指向栈的最底部单元下面的单元

由以上两条可以推理得，寄存器SP的增加和减小都是以2为单位，SP = SP +/- 2。由于在压栈和出栈时只修改寄存器SP的值，所以栈顶的变化范围为0 ~ FFFFH，栈段的最大空间为64KB，一直压栈，当栈满（SP = 0）时，继续压栈，栈顶将环绕，覆盖原来栈中的内容。

操作栈的指令：

| 指令 | 作用       | 举例                                 |
| ---- | ---------- | ------------------------------------ |
| push | 将数据入栈 | push 寄存器；push 段寄存器；push [0] |
| pop  | 将输出出栈 | pop 寄存器； pop 段寄存器； pop [0]  |

#### 2.4 Debug的使用

Debug是DOS、Windows都提供的实模式（8086方式）程序的调试工具。使用debug工具可以查看CPU各种寄存器内存、内存情况以及在机器码级跟踪程序的运行。Debug的命令如下：

| 命令 | 作用                                       | 使用                                                         |
| ---- | ------------------------------------------ | ------------------------------------------------------------ |
| r    | 查看、改变CPU寄存器的内容                  | `-r ax`，按enter键，将出现":"作为输入提示。                  |
| d    | 查看内存中的内容                           | `-d 1000:0`，d命令的格式较多，这里采用"d 段地址：偏移地址"的方式。将列出从指定内存单元开始的128个内存单元内容 |
| e    | 改写内存内容                               | `-e 1000:0 'a' 1 2 3 4 'b' 6 7 8 9`，改写内存1000:0 ~ 1000:9单元中的内容。 |
| u    | 查看写入或原有内存中机器码所对应的汇编指令 | `-u 1000:0`                                                  |
| t    | 执行一条或多条汇编指令                     | `-t`                                                         |
| a    | 已汇编指令的形式在内存中写入机器指令       | `-a`                                                         |
| g    | 程序直接执行到相应地址(0016)并停止         | `g 0016`                                                     |



### 第四章 一个基本的汇编程序

#### 4.1 一个简单的汇编程序

```assembly
assume cs:codesg		; assume为伪指令，假设某一段寄存器与程序中的segment...ends段相关联

codesg segment			; codesg为标号，指代了一个地址，codesg放在segment前面，也作为一个段名称。

	mov ax, 123h
	mov bx, 456h
	add ax, ax
	add bx, ax
	
	mov ax, 4c00h		; 程序返回，通过后续的课程可知，int 21h触发21h号中断 
	int 21h

codesg ends

end
```

保存以上源代码为D:\1.asm，接下通过编译器和链接器对程序进行编译和链接，生成可执行文件。

* masm D:\1.asm;   ------ 编译，生成目标文件
* link D:\1.obj;          ------ 链接目标文件，生成可执行文件

* debug D:\1.exe      ------ 用debug来跟踪一个程序的运行过程

#### 4.2 DOS加载exe文件的过程

结合书本图4.20，需要知道的内容为以下几点：

* DOS会为exe文件找到一段起始地址为SA:0000的内存空闲区，所以此时**DS = SA，IP = 0000H**。
* 空闲内存区的前256个字节会被保留下来用作程序段前缀区（PSP），DOS通过PSP来和被加载的程序进行通信。所以**CS = SA + 10H**
* 用 t 单步执行程序，当执行到`int 21h`时，要用P命令执行。



### 第五章 [BX]和loop指令

#### 5.1 [BX]

[0]表示内存单元，段地址在ds中，偏移地址为0；[bx]同理，也表示一个内存单元，它的偏移地址在bx中，段地址在ds中。

下面将使用描述性符号"**()**"表示一个寄存器或一个内存单元中的内容。eg: (ax)表示ax中的内容，(al)表示al中的内容。用**idata**表示常量。

#### 5.2 loop

loop指令的格式是：loop 标号，CPU执行loop指令的时候，要进行两步操作：

1. (cx) = (cx) - 1
2. 判断cx中的值，不为零则转至标号处执行程序，为零继续向下执行

```assembly
; 计算2^12的结果
assume cs:code
code segment
	mov ax, 2
	
	mov cx, 11
s:					; 标号，标识了一个地址，这个地址处有一条指令add ax, ax
	add ax, ax
	loop s
	
	mov ax, 4c00h
	int 21h
code ends
end
```

#### 5.3 Debug与汇编编译器masm对指令的不同处理

对于指令`mov ax,[0]`，debug将`[0]`解释为一个内存单元，0为它的偏移地址，而编译器将`[0]`直接解释为0，而非预期的内存单元，要想二者统一，则需要在源代码中显示的给出段地址所在的段寄存器，将指令改为`mov ax, ds:[0]`。对于指令`mov ax, [bx]`，通过bx间接给出内存单元的偏移地址，Debug和编译器的行为一直，默认段地址在ds中。

综合可知，在写汇编程序的过程中，为了减少bug的产生，对于内存单元的表示可以统一采用`ds:[idata]`或`ds:[bx]`的形式。

计算ffff:0 ~ ffff:b单元中的数据和，结果存储在dx中：

```assembly
; 如何将8位数据累加到16位的寄存器中
; 方法：通过一个16位中间寄存器过渡
assume cs:code
code segment
	mov ax, 0ffffh		; 在汇编程序中，数据不能以字母开头 
	mov ds, ax
	mov bx, 0
	
	mov dx, 0
	mov cx, 12
s:
	mov al, ds:[bx]		; 将8位数据复制到ax的低8位，ax的高8位赋0
	mov ah, 0
	add dx, ax
	inc bx
	loop s
	
	mov ax, 4c00h
	int 21h
code ends
end
```

在访问内存单元的指令中，用于显示地指明内存单元的段地址的"ds:"、"cs:"、"ss:"、"es:"，在汇编语言中称为**“段前缀”**



### 第六章 包含多个段的程序

#### 6.1 在代码段中定义数据和栈

用伪指令end确认程序的结束和**程序的入口**，当程序被加载入内存后，加载者从程序的可执行文件的描述信息中读到程序的入口地址，设置CS:IP。

```assembly
; 实现对0123h, 0456h, 0789h, 0abch四个数据的累加，结果保存在ax寄存器中
assume cs:code

code segment
	dw 0123h, 0456h, 0789h, 0abch	; 开辟了4个字的内存空间
start:								; 确定程序入口，跳过前面的数据段
	mov bx, 0
	mov ax, 0
	
	mov cx, 4
s:
	add ax, cs:[bx]
	add bx, 2
	loop s
	
	mov ax, 4c00h
	int 21h
code ends
end start
```

要想在代码段中定义栈，除了和定义数据一样，需要在代码段中开辟内存空间，还需要修改SS:IP，使之指向代码栈所对应的内存空间的栈底元素的下一个内存单元。

```assembly
assume cs:code

code segment
	dw 0123h, 0456h, 0789h, 0abch
	dw 0, 0, 0, 0					; 开辟4个字的内存空间，当作栈来使用
start:
	mov ax, cs
	mov ss, ax
	mov sp, 10h						; 设置栈顶ss:sp指向cs:10h
	
	...

	mov ax, 4c00h
	int 21h
code ends
end start
```

#### 6.2 代码段，数据段，栈段

在上一节的代码中，我们在程序段中定义了数据，开辟了对应的内存空间，但这样做会存在一定的弊端，8086CPU的最大段容量为64KB【因为指令指针寄存器IP为16位】，若当前要开辟的数据空间超过64KB，则就不能将程序，数据放在一个段中，需要对其进行分段处理。定义数据段和栈段的方式和定义代码段相同。

```assembly
assume cs:code, ds:data, ss:stack

data segment
	dw 0123h, 0456h, 0789h, 0abch
data ends

stack segment
	dw 0, 0, 0, 0
stack segment


code segment
start:	
	mov ax, stack		; 设置栈顶ss:sp指向stack
	mov ss, ax
	mov sp, 8			; 分段后，sp指向栈段的栈底元素的下一个内存单元
	
	mov ax, data		; 使ds指向data段
	mov ds, ax
	
	mov bx, 0
	...
	mov ax, 4c00h
	int 21h
code ends

end start
```

可以看出：

* 段名相当于一个标号，它代表了段地址，一个数据在段中的段地址可以由段名代替，它的偏移地址就要看它在段中的位置。
* 在源程序中，我们将程序分为data、stack、code三段，但CPU并不清楚，CPU并不会主动从code段开始执行，并将stack段作为栈数据，assume伪指令并被CPU所执行，只在编译器中生效，也是仅在源程序中存在的信息，不必深究assume的作用。
* 要想CPU按照段设计的预期执行，就必须用机器指令控制。总的来说，CPU如何执行段中的内容，是作为指令，还是数据访问，还是栈空间，完全依靠程序中具体的汇编指令，由汇编指令对CS:IP、SS:SP、DS寄存器的设置来决定。



### 第七章 更灵活的内存定位方法

#### 7.1 [bx + idata]

前面的章节中，我们用`[bx]`来指明一个内存单元，还可以用一种更灵活的方式：`[bx + idata]`，它的偏移地址为(bx) + idata，将bx中的数值加上idata。

例如：

```assembly
mov ax, [bx + 200] ; 可以数字化的描述为(ax) = ((ds) * 16 + (bx) + 200)
; 另外三种写法
mov ax, [200 + bx]
mov ax, 200[bx]
mov ax, [bx].200
```

#### 7.2 SI和DI

si和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用。

```assembly
codesg segment
start:
	mov ax, datasg
	mov ds, ax
	mov si, 0
	mov cx, 8
s:
	mov ax, 0[si]
	mov 16[si], ax
	add si, 2
	loop s
	
	mov ax, 4c00h
	int 21h
codesg ends
end start
```

#### 7.3 [bx+si]和[bx+di]

[bx+si]与[bx+di]的含义相近，[bx+si]表示一个内存单元，它的偏移地址为(bx)+(si)

```assembly
mov ax, [bx+si]		; (ax) = ((ds) * 16 + (bx) + (si))
; 另外一种写法
mov ax, [bx][si]
```

#### 7.4 [bx+si+idata]和[bx+di+idata]

[bx+si+idata]表示一个内存单元，它的偏移地址为(bx)+(si)+idata

```assembly
mov ax, [bx+si+idata]	; 数字化描述为：(ax) = ((ds*16) + (bx) + (si) + idata)
; 另外一种写法
mov ax, [bx+idata+si]
mov ax, [idata+bx+si]
mov ax, 200[bx][si]
mov ax, [bx].200[si]
mov ax, [bx][si].200
```

### 第八章 数据处理的两个基本问题

* 处理的数据在什么地方？
* 要处理的数据有多长？

寄存器reg：ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、**bp**、si、di

段寄存器sreg：ds、ss、cs、es

#### 8.1 bx、si、di和bp

* 在8086CPU中只有这4个寄存器可以用在[...]用来进行内存单元的寻址

* 这4个寄存器可以单独出现，也可以以4种组合出现

| bs+si | bx+di | bp+si | bp+di |
| ----- | ----- | ----- | ----- |

* 在[...]中使用寄存器bp，而指令中没有显性给出段地址寄存器，段地址就默认在ss中

#### 8.2 四种寻址方式

| 寻址方式         | 常用格式               |
| ---------------- | ---------------------- |
| 寄存器间接寻址   | [bx]、[si]、[di]、[bp] |
| 寄存器相对寻址   | [bx+idata] , ...       |
| 基址变址寻址     | [bx+si]                |
| 相对基址变址寻址 | [bx+si+idata]          |

一般来说，我们可以用[bx+idata+si]的方式来访问结构体中的数据，用bx定位整体结构体，用idata定位结构体中某一个数据项，用si定位数组项中的每个元素。采用更贴切的书写方式可以写作：[bx].idata[si]

#### 8.3 指令要处理的数据有多长

8086CPU的指令可以处理byte和word两种尺寸的数据

* 通过寄存器指明要处理的数据长度，`mov bx，ds:[0]`
* 通过操作符X ptr指令内存单元的长度，X在汇编中可以为word和byte，`mov word ptr ds:[0], 1`

* 其他方式，有些指令默认了访问了是字单元还是字节单元，比如push指令只进行字操作

#### 8.4 div指令

div是除法指令，需要注意：

* div分为8位除法和16位除法两种，在内存或寄存器中
* 8位除法：被除数为16位，放在AX中，AL存储除法操作的商，AH存储除法操作的余数；
* 16位除法：被除数DX为32位，DX存放被除数高16位，AX存放被除数低16位，除法操作后，AX存储除法操作的商，DX存储除法操作的余数。

```assembly
div reg/内存单元
; 内存单元
div byte ptr ds:[0]
div word ptr ds:[0]
```

#### 8.5 dd和dup

* dd：伪指令，定义dword型数据
* dup：一个操作符，与dd一样，用来定义数据的重复

```assembly
db 3 dup (0)	; 定义3个字节，他们的值都是0，相当于db 0, 0, 0
db 3 dup (0,1,2)	; 定义9个字节，相当于db 0, 1, 2, 0, 1, 2, 0, 1, 2
```



### 第九章 转移指令的原理

可以修改IP，或者同时修改CS和IP的指令统称为转移指令

* 段内转移：只修改IP
  * 段内短转移：IP的修改范围为-128 ~ 127。
  * 段内近转移：IP的修改范围为-32768 ~ 32767。 
* 段间转移：同时修改CS和IP

#### 9.1 操作符offset

offset由编译器处理，功能是获取标号的偏移地址。

```assembly
assume cs:code
code segment
 start:
 	mov ax, offset start	; 相当于mov ax, 0
 s:
 	mov ax, offset s		; 相当于mov ax, 3, s是代码段中的标号，它所标记的指令是代码段的第二条指令，第一条指令长度为3个字节，则s的偏移地址为3
    
    mov ax, 4c00h
    int 21h
code ends
end start
```

#### 9.2 jmp指令

jmp为无条件转移指令，可以只修改IP，也可以同时修改IP和CS。

jmp指令要给出两种信息：

* 转移的目的地址
* 转移的距离（段间转移、段内短转移、段内近转移）

不同的给出目的地址的方法，和不同的转移位置，对应有不同格式的jmp指令。

##### 9.2.1 依据位移进行转移

* **jmp short 标号**（转到标号处执行指令）

这种格式的jmp指令实现的是**段内短转移**，他对IP的修改范围为-128 ~ 127。jmp指令中的标号是代码段中的标号，指明了指令要转移的目的地址，转移指令结束后，CS:IP应该指向标号出的指令。

```assembly
assume cs:codesg
codesg segment
 start:						; 编译器处理后的指令		  机器码
 	mov ax, 0				; mov ax, 0000			B80000
 	jmp short s				; jmp 0008				EB03
 	add ax, 1				; add ax, 0001			050100
 s:
 	inc ax
codesg ends
end start
```

可以看出 jmp 0008或jmp short s所对应的机器码为**EB03**，这个机器码中竟不包含转移的目的地址。这说明**CPU在执行jmp指令的时候并不需要转移的目的地址。**

**03**是jmp指令的下一条指令到标号s处的偏移长度。根据CPU指令的执行过程，在jmp short s执行前，此时指令指针寄存器IP已经更新并指向jmp short s的下一条指令。

所以，`jmp short 标号`功能的本质是： (IP) = (IP) + 8位位移。位移由编译程序在编译时计算出。

* **jmp near ptr 标号**

 实现的是段内近转移，(IP) = (IP) + 16位位移。

##### 9.2.2 转移的目的地址在指令中

以上jmp指令对应的机器指令中并没有转移的目的地址，而是相对于当前IP的转移位移。

* **jmp far ptr 标号**

"**jmp far ptr** 标号"实现的是段间转移，又称为远转移。功能为：

(CS) = 标号所在段的段地址。

(IP) = 标号在段中偏移地址。

far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。

##### 9.2.3 转移地址在寄存器中

* **jmp 16位reg**

功能：(IP) = (16位reg)

##### 9.2.4 转移地址在内存中

转移地址在内存中的jmp指令有两种格式：

* **jmp word ptr 内存单元地址（段内转移）**

功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。

```assembly
mov ax, 0123H
mov ds:[0], ax
jmp word ptr ds:[0]		; 执行后，(IP) = 0123H
```

* **jmp dword ptr 内存单元地址 （段间转移）**

功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。

  (CS)   = （内存单元地址+2）

（IP） =  (内存单元地址)

```assembly
mov ax, 0123H
mov ds:[0], ax
mov word ptr ds:[2], 0
jmp dword ptr ds:[0]	; 执行后，(CS) = 0, (IP) = 0123H
```

#### 9.3 jcxz指令

jcxz指令为有条件转移指令，所有的有条件转移指令都是**短转移**，在对应的机器码中包含转移的位移，而不是目的地址，对IP的修改范围为-128 ~ 127。

指令格式：**jcxz 标号**，如果cx = 0，转移到标号处执行

操作：当(cx) == 0时，(IP) = (IP) +8位位移；当(cx) != 0时，什么都不做，程序继续向下执行。**可以用来判定变量是否为0**

#### 9.4 loop指令

loop指令为循环指令，所有的循环指令都是**短转移**，在对应的机器码中包含转移的位移，而不是目的地址，对IP的修改范围为-128 ~ 127。

指令格式：loop 标号，(cx) = (cx) - 1，如果(cx) != 0，转移到标号处执行。

操作：

* (cx) = (cx) - 1
* 如果(cx) != 0，(IP) = (IP) + 8位位移，当(cx) == 0时，什么都不做，程序继续向下执行。可以用来做循环处理。

#### 9.5 8086CPU显示缓冲区的结构

8086CPU存在一个80x25【25行80列】的彩色字符模式显示缓冲区，其结构为：

地址空间为**B800H ~ BFFFH** 共**32KB**的空间，为80x25彩色字符模式的显示缓冲区，向这个地址空间写入数据，写入的内容将立即显示在显示器上。

在这个模式下，每个字符有256种属性，一个字符占**两个字节**，分别存放**字符的ASCII码**和**属性**，在80x25模式下，一屏的内容在显示缓冲区中共占4000个字节，显示缓冲区分为8页，每页4KB，显示器可以显示任意一页的内容。一般情况下，显示第0页的内容，也就是B800H ~ B8F9FH中的4000个字节内容将出现在显示器上

属性字节的格式：

​					7		6		5		4		3		2		1		0

含义：	    BL	  R        G       B        I         R        G       B

​				 闪烁	         背景		    高亮		  	前景

### 第十章 CALL和RET指令

#### 10.1 ret和retf

* ret指令用栈中的数据，修改IP的内容，从而实现**近转移**；
* retf指令用栈中的数据，修改CS和IP的内容，从而实现**远转移**； 

CPU执行ret指令的时候，进行下面两步操作：

* (1) （IP) = ((SS) * 16 + (SP))
* (2)   (SP) = (SP) + 2

CPU执行retf指令的时候，进行下面4步操作：

* (1) (IP) = ((SS) * 16 + (sp))
* (2) (sp) = (sp) + 2
* (3) (CS) = ((SS) * 16 + (sp))
* (4) (SP) = (SP) + 2

#### 10.2 call指令

CPU执行call指令的时候，进行两步操作

* (1) 将当前的IP或CS和IP压入栈中
* (2) 转移

call指令不能实现短转移。call指令实现转移的方法和jmp指令类似

##### 10.2.1 依据位移进行转移

**call 标号**（将当前的**IP**压栈后，转到标号处执行指令）

CPU执行此种call指令，进行如下操作：

* (SP) = (SP) - 2

  ((SS) * 16 + (SP)) = (IP)

* (IP) = (IP) + 16位位移

16位位移由编译程序在编译时算出。

相当于：

```assembly
push IP
jmp near ptr 标号
```

##### 10.2.2 转移的目的地址在指令中

**call far ptr 标号**: 段间转移

CPU执行此种格式的call指令时，进行如下操作：

* (SP) = (SP) - 2

​		((SS) * 16 + (SP)) = (CS)

​		(SP) = (SP) - 2

​		((SS) * 16 + (SP)) = (IP)

* (CS) = 标号所在段的段地址

  (IP) = 标号所在段的偏移地址

相当于

```assembly
push CS
push IP
jmp far ptr 标号
```

##### 10.2.3 转移地址在寄存器中的call指令

**call 16位reg**

功能：

* (SP) = (SP) - 2
* ((SS) * 16 + (SP)) = (IP)
* (IP) = (16位reg)

相当于

```assembly
push IP
jmp 16位reg
```

##### 10.2.4 转移地址在内存中

* call word ptr 内存单元地址

相当于

```assembly
push IP
jmp word ptr 内存单元地址
```

* call dword ptr 内存单元地址

相当于

```assembly
push CS
push IP
jmp dword ptr 内存单元地址
```

#### 10.3 call 和 ret的配合使用

标准子程序框架

```assembly
主程序开始
	调用子程序
主程序结束

; 
子程序开始：
	子程序中使用的寄存器入栈
	
	子程序内容
	
	子程序中使用的寄存器出栈
	
	返回(ret、retf)
```

#### 10.4 mul 乘法指令

指令格式：

* mul reg
* mul 内存单元

注意：

* (1) 两个相乘的数，要么都是8位，要么都是16位；如果是8位，则一个默认在AL中，另一个在8位reg或者内存单元中；如果是16位，一个默认在ax中，另一个放在16位的reg或内存单元中
* (2) 乘法结果：8位乘法，结果默认在ax中；16位乘法，结果高位默认在DX中，低位在AX中

```assembly
; 内存单元
mul byte ptr ds:[0]
mul word ptr [bs+si+8]
; 寄存器
mov al, 100
mov bl, 100
mul bl
```







